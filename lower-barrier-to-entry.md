# Lowering the Barrier to Entry for Development

# Introduction
My first computer was a Commodore 64 that upon boot dropped me to a command prompt that ran BASIC. Soon thereafter I'd find my way to the Apple II series which offered the same experience. Microsoft DOS didn't offer it at the terminal but some variant of basic (most famously QBasic) came bundled with the system and with later Windows systems as well.

When I became a (relatively) early internet adopter the ISP I used (AOL) bundled web hosting with internet access and creating pages that others would actually read could be accomplished in straight HTML. Over time tidbits of CSS and JavaScript became useful too.

The barrier to entry was low, the tools were free, and the time to visible and pleasing results was minimal. Not anymore.

# Don't Want to Go Back
I'm not stuck in a nostalgic past, I don't want to return to those old ways because the "things" we created (applications, pages, etc.) were much more limited than those we can build today.

That said, I do think we have a real issue with being approachable. While we have more powerful systems with more rapid tools for development and more resources from which to learn this has not made:

(a) it easier for individuals to get started in development
or
(b) allow hobbyists/casual developers to create more innovative solutions

We need a simpler way to introduce individuals to development and to facilitate the implementation of hobbyist ideas by individuals with constrained resources (especially time).

# What to Do?
There are several ways in which we could simplify the barriers to new/casual developers. At one time I thought the path forward might be a new development stack, or at least a DSL within an existing development stack. But the proliferation of languages and tools has made me doubt the wisdom of this approach.

Instead I would like to propose three potential ways forward.

# 1. A Conceptual Subset
Look at any of the popular roadmaps for learning development technologies scattered across github and you'll see paths of significant complexity that look quite overwhelming to experienced developers, much less to new or casual ones.

For this reason I would suggest we create a standardized subset of concepts which are necessary for the creation of "normal" applications.

(See Appendix A for examples of what this subset might look like)

# 2. A Bidirectional Transpilation Tool


# 3. Simplified Development Environments
